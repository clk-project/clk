#!/usr/bin/env python3
"""Analyze per-test coverage files to find redundant tests.

This script reads coverage files generated by pytest and identifies tests
whose coverage is fully included in the union of other tests' coverage.
"""

import argparse
import sys
from collections import defaultdict
from functools import reduce
from pathlib import Path

import coverage


def load_coverage_data(coverage_file):
    """Load coverage data from a file and return {filename: set(lines)}."""
    cov = coverage.Coverage(data_file=str(coverage_file))
    cov.load()
    data = cov.get_data()

    result = {}
    for filename in data.measured_files():
        lines = data.lines(filename)
        if lines:
            result[filename] = set(lines)
    return result


def get_test_name(coverage_file):
    """Extract test name from coverage filename."""
    name = coverage_file.name
    # Remove .coverage. prefix
    if name.startswith(".coverage.pytest."):
        return name[len(".coverage.pytest.") :]
    elif name.startswith(".coverage."):
        return name[len(".coverage.") :]
    return name


def merge_coverage(cov_a, cov_b):
    """Merge two coverage dicts, returning union of covered lines."""
    result = defaultdict(set)
    for filename, lines in cov_a.items():
        result[filename].update(lines)
    for filename, lines in cov_b.items():
        result[filename].update(lines)
    return dict(result)


def merge_all_coverage(coverages):
    """Merge multiple coverage dicts."""
    if not coverages:
        return {}
    return reduce(merge_coverage, coverages, {})


def coverage_size(cov):
    """Return total number of covered lines."""
    return sum(len(lines) for lines in cov.values())


def coverage_difference(cov_a, cov_b):
    """Return lines in cov_a that are not in cov_b."""
    result = {}
    for filename, lines_a in cov_a.items():
        lines_b = cov_b.get(filename, set())
        diff = lines_a - lines_b
        if diff:
            result[filename] = diff
    return result


def is_subset(cov_a, cov_b):
    """Check if cov_a is a subset of cov_b."""
    for filename, lines_a in cov_a.items():
        lines_b = cov_b.get(filename, set())
        if not lines_a.issubset(lines_b):
            return False
    return True


def analyze_redundancy(test_coverages):
    """Analyze which tests are redundant.

    Returns:
        redundant: list of (test_name, covering_tests) tuples
        unique: dict of {test_name: unique_coverage}
    """
    redundant = []
    unique = {}

    test_names = list(test_coverages.keys())

    for i, test_a in enumerate(test_names):
        cov_a = test_coverages[test_a]
        if not cov_a:
            continue

        # Compute union of all other tests' coverage
        union_others = {}
        for j, test_b in enumerate(test_names):
            if i != j:
                union_others = merge_coverage(union_others, test_coverages[test_b])

        # Check if test_a is fully covered by others
        if is_subset(cov_a, union_others):
            # Find which tests cover this one
            covering_tests = []
            for test_b in test_names:
                if test_a != test_b and is_subset(cov_a, test_coverages[test_b]):
                    covering_tests.append(test_b)
            redundant.append((test_a, covering_tests))
        else:
            # Compute unique contribution
            unique_cov = coverage_difference(cov_a, union_others)
            unique[test_a] = unique_cov

    return redundant, unique


def find_subset_tests(test_coverages):
    """Find tests that are strict subsets of other individual tests."""
    subsets = []
    test_names = list(test_coverages.keys())

    for i, test_a in enumerate(test_names):
        cov_a = test_coverages[test_a]
        if not cov_a:
            continue

        size_a = coverage_size(cov_a)

        for j, test_b in enumerate(test_names):
            if i >= j:
                continue

            cov_b = test_coverages[test_b]
            if not cov_b:
                continue

            size_b = coverage_size(cov_b)

            # Check if one is subset of the other
            if is_subset(cov_a, cov_b) and size_a < size_b:
                subsets.append((test_a, test_b, size_a, size_b))
            elif is_subset(cov_b, cov_a) and size_b < size_a:
                subsets.append((test_b, test_a, size_b, size_a))

    return subsets


def main():
    parser = argparse.ArgumentParser(
        description="Analyze per-test coverage to find redundant tests"
    )
    parser.add_argument(
        "coverage_dir",
        type=Path,
        help="Directory containing per-test coverage files",
    )
    parser.add_argument(
        "--show-unique",
        action="store_true",
        help="Show unique coverage details for each test",
    )
    parser.add_argument(
        "--show-subsets",
        action="store_true",
        help="Show tests that are subsets of other individual tests",
    )
    parser.add_argument(
        "--min-unique-lines",
        type=int,
        default=0,
        help="Only show tests with at least this many unique lines",
    )
    args = parser.parse_args()

    if not args.coverage_dir.is_dir():
        print(f"Error: {args.coverage_dir} is not a directory", file=sys.stderr)
        sys.exit(1)

    # Find all coverage files
    coverage_files = list(args.coverage_dir.glob(".coverage.*"))
    # Filter out pytest hook files if corresponding subprocess file exists
    # (subprocess files have actual coverage, pytest hook files are often empty)
    subprocess_files = [f for f in coverage_files if ".coverage.pytest." not in f.name]

    print(f"Found {len(subprocess_files)} per-test coverage files")
    print()

    # Load coverage data
    test_coverages = {}
    for cov_file in subprocess_files:
        test_name = get_test_name(cov_file)
        try:
            test_coverages[test_name] = load_coverage_data(cov_file)
        except Exception as e:
            print(f"Warning: Failed to load {cov_file}: {e}", file=sys.stderr)

    print(f"Loaded coverage for {len(test_coverages)} tests")
    print()

    # Show subset relationships if requested
    if args.show_subsets:
        print("=" * 70)
        print("SUBSET RELATIONSHIPS (test A is fully covered by test B)")
        print("=" * 70)
        subsets = find_subset_tests(test_coverages)
        if subsets:
            for test_a, test_b, size_a, size_b in sorted(subsets, key=lambda x: -x[2]):
                print(f"  {test_a} ({size_a} lines)")
                print(f"    -> subset of: {test_b} ({size_b} lines)")
                print()
        else:
            print("  No subset relationships found")
        print()

    # Analyze redundancy
    print("=" * 70)
    print("REDUNDANCY ANALYSIS")
    print("=" * 70)
    redundant, unique = analyze_redundancy(test_coverages)

    if redundant:
        print(f"\nRedundant tests ({len(redundant)} tests covered by others):")
        for test_name, covering_tests in sorted(redundant):
            print(f"  - {test_name}")
            if covering_tests:
                print(f"    Fully covered by: {', '.join(covering_tests[:3])}")
                if len(covering_tests) > 3:
                    print(f"    ... and {len(covering_tests) - 3} more")
    else:
        print("\nNo fully redundant tests found.")

    print(f"\nTests with unique coverage ({len(unique)} tests):")
    unique_sorted = sorted(unique.items(), key=lambda x: -coverage_size(x[1]))

    for test_name, unique_cov in unique_sorted:
        unique_lines = coverage_size(unique_cov)
        if unique_lines >= args.min_unique_lines:
            print(f"  - {test_name}: {unique_lines} unique lines")
            if args.show_unique:
                for filename, lines in sorted(unique_cov.items()):
                    short_name = filename.split("/")[-1]
                    print(f"      {short_name}: lines {sorted(lines)[:10]}...")

    print()
    print("=" * 70)
    print("SUMMARY")
    print("=" * 70)
    total_coverage = merge_all_coverage(list(test_coverages.values()))
    total_lines = coverage_size(total_coverage)
    print(f"Total tests analyzed: {len(test_coverages)}")
    print(f"Redundant tests: {len(redundant)}")
    print(f"Tests with unique coverage: {len(unique)}")
    print(f"Total unique lines covered: {total_lines}")


if __name__ == "__main__":
    main()
