:PROPERTIES:
:ID:       a197f802-e04c-40a2-8bfa-bc96ba703252
:END:
#+language: en
#+EXPORT_FILE_NAME: ./using_a_plugin.md

#+CALL: ../../lp.org:check-result()

#+name: init
#+BEGIN_SRC bash :results none :exports none :session a197f802-e04c-40a2-8bfa-bc96ba703252
  . ./sandboxing.sh
#+END_SRC

In the past, clk contained a command used to add hooks before and after other
commands. This was highly advanced stuff and eventually was barely used. It was
removed from clk. But, with the plugin mechanism, you actually can put this feature back into clk.

* installing a plugin
  :PROPERTIES:
  :CUSTOM_ID: installing-a-plugin
  :END:

To install a plugin in clk, you need to place the plugin file in the ~plugins~
directory of your clk configuration folder. By default, this is
~~/.config/clk/plugins/~.

For example, to install the trigger plugin shown below, you would:

1. Create the plugins directory if it doesn't exist:

#+NAME: create_plugins_dir
#+BEGIN_SRC bash :results none :exports code
mkdir -p ~/.config/clk/plugins
#+END_SRC

2. Copy or create the plugin file:

#+BEGIN_SRC bash :results none :exports code
cp myplugin.py ~/.config/clk/plugins/
#+END_SRC

The plugin will be automatically loaded the next time you run clk.

Note that plugins must have a ~load_plugin()~ function that will be called when
clk loads them. This function is responsible for initializing the plugin,
registering commands, and performing any necessary setup.

Let's test this with the trigger plugin.

* the trigger plugin code
  :PROPERTIES:
  :CUSTOM_ID: the-trigger-plugin-code
  :END:

The plugin is kept in clk repository.

To install it try something like:

#+BEGIN_SRC bash :results none :exports code
mkdir -p ~/.config/clk/plugins
wget -O ~/.config/clk/plugins/trigger.py \
  https://raw.githubusercontent.com/clk-project/clk/main/contrib/plugin/trigger.py
#+END_SRC

#+NAME: install_plugin
#+BEGIN_SRC bash :results none :exports none :session a197f802-e04c-40a2-8bfa-bc96ba703252
mkdir -p "${CLKCONFIGDIR}/plugins"
cp "${SRCDIR}/../../contrib/plugin/trigger.py" "${CLKCONFIGDIR}/plugins/trigger.py"
#+END_SRC

Once copied in the plugin directory, you should be able to see it listed in the list of plugins...

#+NAME: show-plugin
#+BEGIN_SRC bash :results verbatim :exports both :session a197f802-e04c-40a2-8bfa-bc96ba703252 :cache yes
clk plugin show
#+END_SRC

#+RESULTS[930ad0342e7b300ca925352bf09e1ef4867d0b6a]: show-plugin
: trigger Trigger plugin - run commands before/after other commands.

...and use the injected command like any other.

#+NAME: verify_plugin
#+BEGIN_SRC bash :results verbatim :exports both :session a197f802-e04c-40a2-8bfa-bc96ba703252 :cache yes
clk trigger --help | head -15
#+END_SRC

#+RESULTS[73b6d8a305098a50a2908a37aa9cdb50ec59dab5]: verify_plugin
#+begin_example
Usage: clk trigger [OPTIONS] COMMAND [ARGS]...

  Manipulate command triggers.

  Triggers allow you to automatically run commands before or after other commands. This is useful for working around
  issues in tools or adding consistent behaviors.

  To run command B before command A:

      clk trigger set pre A B

  To run command B only after successful execution of A:

      clk trigger set success A B
#+end_example


* using triggers
  :PROPERTIES:
  :CUSTOM_ID: using-triggers
  :END:

Now that the plugin is installed, let's explore how to use triggers effectively.
Triggers allow you to automatically run commands before or after other commands,
which is useful for adding consistent behaviors or working around issues in tools.

** setting and showing a trigger
   :PROPERTIES:
   :CUSTOM_ID: setting-and-showing-a-trigger
   :END:

Let's start by creating a simple command and setting a pre-trigger on it. First,
we'll create an alias that we can attach a trigger to:

#+NAME: create_alias
#+BEGIN_SRC bash :results none :exports code :session a197f802-e04c-40a2-8bfa-bc96ba703252
clk alias set mycommand echo 'main command'
#+END_SRC

Now let's set a pre-trigger that will run before ~mycommand~:

#+NAME: set_trigger
#+BEGIN_SRC bash :results none :exports code :session a197f802-e04c-40a2-8bfa-bc96ba703252
clk trigger set pre mycommand echo hello
#+END_SRC

We can verify that the trigger was set by showing it:

#+NAME: show_trigger
#+BEGIN_SRC bash :results verbatim :exports both :session a197f802-e04c-40a2-8bfa-bc96ba703252 :cache yes
clk trigger show --no-color pre mycommand
#+END_SRC

#+RESULTS[35a18865be353eb072a8677718d8603a16de1a51]: show_trigger
: mycommand echo hello

** pre-trigger execution
   :PROPERTIES:
   :CUSTOM_ID: pre-trigger-execution
   :END:

When we run ~mycommand~, the pre-trigger executes first, followed by the main
command:

#+NAME: run_with_pre_trigger
#+BEGIN_SRC bash :results verbatim :exports both :session a197f802-e04c-40a2-8bfa-bc96ba703252 :cache yes
clk mycommand
#+END_SRC

#+RESULTS[c97bcfd900ba0638189e393062547b297fc09aae]: run_with_pre_trigger
: hello
: main command

As you can see, "hello" appears before "main command", demonstrating that the
pre-trigger runs before the actual command.

** success triggers
   :PROPERTIES:
   :CUSTOM_ID: success-triggers
   :END:

You can also set triggers that only run after a command succeeds. Let's create a
new command and add a success trigger:

#+NAME: create_success_alias
#+BEGIN_SRC bash :results none :exports code :session a197f802-e04c-40a2-8bfa-bc96ba703252
clk alias set buildcmd echo 'build complete'
clk trigger set success buildcmd echo 'after success'
#+END_SRC

#+NAME: run_with_success_trigger
#+BEGIN_SRC bash :results verbatim :exports both :session a197f802-e04c-40a2-8bfa-bc96ba703252 :cache yes
clk buildcmd
#+END_SRC

#+RESULTS[539bc0a007bf10503319fd007febf2a435ab281a]: run_with_success_trigger
: build complete
: after success

** unsetting a trigger                                              :Context:
   :PROPERTIES:
   :CUSTOM_ID: unsetting-a-trigger
   :END:

To remove a trigger, use the ~unset~ command:

#+NAME: unset_trigger
#+BEGIN_SRC bash :results none :exports code :session a197f802-e04c-40a2-8bfa-bc96ba703252
clk trigger unset pre mycommand
#+END_SRC

After unsetting, only the main command runs:

#+NAME: run_after_unset
#+BEGIN_SRC bash :results verbatim :exports both :session a197f802-e04c-40a2-8bfa-bc96ba703252 :cache yes
clk mycommand
#+END_SRC

#+RESULTS[c97bcfd900ba0638189e393062547b297fc09aae]: run_after_unset
: main command
** listing triggers with --name-only
   :PROPERTIES:
   :CUSTOM_ID: listing-triggers-name-only
   :END:

When you have many triggers, you can list just the command names that have
triggers:

#+NAME: setup_name_only
#+BEGIN_SRC bash :results none :exports code :session a197f802-e04c-40a2-8bfa-bc96ba703252
clk alias set cmd1 echo 'one'
clk alias set cmd2 echo 'two'
clk trigger set pre cmd1 echo 'trigger1'
clk trigger set pre cmd2 echo 'trigger2'
#+END_SRC

#+NAME: show_name_only
#+BEGIN_SRC bash :results verbatim :exports both :session a197f802-e04c-40a2-8bfa-bc96ba703252 :cache yes
clk trigger show pre --name-only
#+END_SRC

#+RESULTS[34cbca697b32b43c5e9664f756965af7a3f32c53]: show_name_only
: buildcmd
: cmd1
: cmd2

#+BEGIN_SRC bash :exports none :tangle ../../tests/use_cases/using_a_plugin.sh :noweb yes :shebang "#!/bin/bash -eu"
<<init>>

<<install_plugin>>

check-result(show-plugin)

check-result(verify_plugin)

<<create_alias>>

<<set_trigger>>

check-result(show_trigger)

check-result(run_with_pre_trigger)

<<create_success_alias>>

check-result(run_with_success_trigger)

<<unset_trigger>>

check-result(run_after_unset)

<<setup_name_only>>

check-result(show_name_only)
#+END_SRC
