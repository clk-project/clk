:PROPERTIES:
:ID:       85c8e385-7f24-48ac-9a85-30cfc354aebf
:END:
#+LANGUAGE: en
#+EXPORT_FILE_NAME: ./bash_command.md

#+CALL: ../../lp.org:check-result()

#+name: init
#+BEGIN_SRC bash :results none :exports none :session 85c8e385-7f24-48ac-9a85-30cfc354aebf
. ./sandboxing.sh
#+END_SRC

To create a bash command, you can simply call the following command.

#+name: create
#+BEGIN_SRC bash :results none :session 85c8e385-7f24-48ac-9a85-30cfc354aebf
clk command create bash mycommand
#+END_SRC

Your editor will be used to first edit the command. This command will already
contain some code to get you started.

Note that you can always get the help of any command using ~--help~. So don't
hesitate to try.

#+NAME: help-create
#+BEGIN_SRC bash :results verbatim :exports both :session 85c8e385-7f24-48ac-9a85-30cfc354aebf :cache yes
clk command create --help
#+END_SRC

#+RESULTS[7ad0466fff091d1dd4c87bc00dafe2cec6542897]: help-create
#+begin_example
Usage: clk command create [OPTIONS] COMMAND [ARGS]...

  Create custom commands directly from the command line.

  This is a built-in command.

Options:
  --help-all             Show the full help message, automatic options included.
  --extension EXTENSION  Use this extension
  --context              Guess the profile
  --global               Consider only the global profile
  --help                 Show this message and exit.

Commands:
  bash       Create a bash custom command
  from-file  Install the given file as a customcommand, infering its type.
  python     Create a bash custom command
#+end_example


Let's look at this file together.

#+NAME: show_it
#+BEGIN_SRC bash :results verbatim  :session 85c8e385-7f24-48ac-9a85-30cfc354aebf :cache yes
cat $(clk command which mycommand)
#+END_SRC

#+RESULTS[7d3b87635527e2c71dba61b28983f897eb7a8a9f]: show_it
#+begin_example
#!/bin/bash -eu

source "_clk.sh"

clk_usage () {
    cat<<EOF
$0

Description
--

EOF
}

clk_help_handler "$@"
#+end_example

The first part, ~source "_clk.sh"~ loads a few helpers provided by clk to make
your life easier. Among other things, it contains the glue code to make clk
parse your command line.

Then, ~clk_usage~ is responsible to provide the help message and the description
of the options and arguments.

On top of the line with two dashes ~--~ , you write whatever plain text content
you want. It will be available in the ~--help~ output.

Below the ~--~ line, you will write the descriptions of the arguments and
options (see [[file:bash_command_use_option.org][the dedicated tutorial]]).

If you keep the word ~Description~ in the help message, clk will warn you that
you should replace it with something more interesting.

#+name: try
#+BEGIN_SRC bash :results verbatim :exports both  :session 85c8e385-7f24-48ac-9a85-30cfc354aebf :cache yes
clk mycommand
#+END_SRC

#+RESULTS[b51c75a0bbe5bf44990b233b589594473c828e43]: try
: warning: The command 'mycommand' has no documentation

Let's write something in here.

#+name: set_description
#+BEGIN_SRC bash :results none :exports both :session 85c8e385-7f24-48ac-9a85-30cfc354aebf
sed -i 's/Description/Command that says something/g' "$(clk command which mycommand)"
#+END_SRC

#+NAME: help
#+BEGIN_SRC bash :results verbatim :exports both :session 85c8e385-7f24-48ac-9a85-30cfc354aebf :cache yes
clk mycommand --help|sed "s|$(pwd)|.|"
#+END_SRC

#+RESULTS[816a9e78d7a11109944790de77428fd39647abdf]: help
#+begin_example
Usage: clk mycommand [OPTIONS]

  Command that says something

  Edit this external command by running `clk command edit mycommand`
  Or edit ./clk-root/bin/mycommand directly.

Options:
  --help-all  Show the full help message, automatic options included.
  --help      Show this message and exit.
#+end_example


The last part ~clk_help_handler "$@"~ is the glue code that makes clk parse the
command line. After this line, you can write the content of your command line.

Let's make this command say something.

#+name: say_something
#+BEGIN_SRC bash :results none :exports code :session 85c8e385-7f24-48ac-9a85-30cfc354aebf
  cat<<EOF >> "$(clk command which mycommand)"
  echo something
  EOF
#+END_SRC

#+NAME: use_it
#+BEGIN_SRC bash :results verbatim :exports both :session 85c8e385-7f24-48ac-9a85-30cfc354aebf :cache yes
clk mycommand
#+END_SRC

#+RESULTS[b51c75a0bbe5bf44990b233b589594473c828e43]: use_it
: something

clk will try hard to respect the exit code of the bash command.

Let's assume for instance that you created a command that simply exits with the code 5.

#+NAME: create-exit-5
#+BEGIN_SRC bash :results none :exports code :session 85c8e385-7f24-48ac-9a85-30cfc354aebf
  clk command create bash --body "exit 5" --description "Simply exiting with the code 5" exit5
#+END_SRC

Then, let's call it and check its exit code.

#+NAME: exit-5
#+BEGIN_SRC bash :results verbatim :exports both :session 85c8e385-7f24-48ac-9a85-30cfc354aebf :cache yes
clk exit5 || echo $?
#+END_SRC

#+RESULTS[810c710ebd06b1a4c9c46ab7fad8e571670b9497]: exit-5
: 5

Additionally, you can put whatever traps you want in your code and clk will try to respect them.

#+NAME: trap-code
#+BEGIN_SRC bash :results none :exports code :session 85c8e385-7f24-48ac-9a85-30cfc354aebf
  clk command create bash --body "
  clean () {
echo 'cleaning'
}
trap clean EXIT
echo 'starting'
sleep 3600
  " --description "Simply wait but clean before exiting" clean-test
#+END_SRC

  #+NAME: clean_test-command
  #+BEGIN_SRC bash :results none :exports code
    clk clean-test
  #+END_SRC

  #+NAME: generate_expect_clean_test
  #+BEGIN_SRC bash :results none :exports none :noweb yes :session 85c8e385-7f24-48ac-9a85-30cfc354aebf
cat<<EOF > pass.exp
#!/usr/bin/expect -f

set timeout -1
spawn clk clean-test
match_max 100000
expect -exact "starting\r"
sleep 0.1
send "\x03"
expect -exact "cleaning"
expect -exact "\r"
expect -exact "\r"
expect -exact "\r"
expect -exact "Aborted!"
expect eof
EOF
  #+END_SRC

  #+NAME: clean-test-expect
  #+BEGIN_SRC bash :results verbatim :exports results :session 85c8e385-7f24-48ac-9a85-30cfc354aebf :cache yes
    expect pass.exp |tail -n+2
  #+END_SRC

  When starting this command and then killing it with Ctrl-C, you will get.

  #+RESULTS[2a3f753a601200e8c62ae847a25cb45790129b38]: clean-test-expect
  : starting
  : ^Ccleaning
  :
  : Aborted!


#+BEGIN_SRC bash :exports none :tangle ../../tests/use_cases/bash_command.sh :noweb yes :shebang "#!/bin/bash -eu"
<<init>>

<<create>>

check-result(help-create)

check-result(show_it)

check-result(try)

<<set_description>>

check-result(help)

<<say_something>>

check-result(use_it)

<<create-exit-5>>

check-result(exit-5)

<<trap-code>>

<<generate_expect_clean_test>>

check-result(clean-test-expect)
#+END_SRC
